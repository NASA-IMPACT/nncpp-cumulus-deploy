const I = require('iter-tools-es');

/**
 * The type of value returned from a unary function used to "unfold" values via
 * the `asyncUnfold` or `asyncFlatUnfold` function.  Either a pair of values
 * (where the first value is the next value that `*Unfold` should yield, and the
 * second value is the argument that `*Unfold` will pass to the unary function
 * to generate the next pair), or one of the "falsey" values `undefined`,
 * `null`, or `false` (indicating that unfolding is complete, and the unary
 * function should not be called again).
 *
 * @typedef UnfoldResult
 * @type {[T, U] | undefined | null | false}
 * @template T - type of the argument expected by the function that returns this
 *    `UnfoldResult` type
 * @template U - type of the values generated by the function that unfolds such values
 *    via an unfolding function that produces such `UnfoldResult` values
 */

/**
 * A unary function given to `asyncUnfold` or `asyncFlatUnfold`, which is
 * expected to return an `UnfoldResult` or a `Promise` of one.
 *
 * @callback UnfoldFunction
 * @param {T} arg - the sole function argument
 * @returns {UnfoldResult<T, U> | Promise<UnfoldResult<T, U>>}
 * @template T - type of the argument expected by the function
 * @template U - type of the value returned by the function
 */

/**
 * Returns an async generator that yields values from the specified unfolding
 * function.
 *
 * The specified function is initially invoked with the specified seed value as
 * the sole argument.  As soon as the function returns a falsy value, the
 * generator stops generating values.  Otherwise, the specified function is
 * expected to return a pair of values (2-element array).  In this case, the
 * generator yields the first item in the pair, then invokes the specified
 * function again, passing the second element in the pair to the function.
 *
 * @example
 * const f = (x) => x >= 0 && [x, x - 2];
 * const ysFrom = asyncUnfold(f);
 *
 * for await (const y of ysFrom(10)) {
 *   console.log(y);
 * }
 *
 * //=> logs each of the values 10, 8, 6, 4, 2, 0
 *
 * @param {UnfoldFunction<T, U>} f - unary unfolding function that (possibly
 *    asynchronously) generates one item at a time
 * @returns {(seed: T) => AsyncGenerator<U, void, undefined>} an async generator
 *    function that yields each item generated by the unfolding function
 * @template T - type of the argument expected by the function `f`
 * @template U - type of the elements produced by the returned generator
 */
function asyncUnfold(f) {
  return async function* makeAsyncGenerator(seed) {
    for (
      let input, output, result = await f(seed);
      result && ([output, input] = result);
      result = await f(input)
    ) {
      yield output;
    }
  }
}

/**
 * Returns an async generator that yields values from the specified unfolding
 * function.
 *
 * The specified function is initially invoked with the specified seed value as
 * the sole argument.  As soon as the function returns a falsy value, the
 * generator stops generating values.  Otherwise, the specified function is
 * expected to return a pair of values (2-element array).  In this case, the
 * generator individually yields each element of the first item (expected to be
 * an iterable value) in the pair, then invokes the specified function again,
 * passing the second element in the pair to the function.
 *
 * @example
 * const pager = (x) => x > 0 && [[x, x - 1], x - 2];
 * const ysFrom = asyncFlatUnfold(pager);
 *
 * for await (const y of ysFrom(4)) {
 *   console.log(y);
 * }
 *
 * //=> logs each of the values 4, 3, 2, 1
 *
 * @param {UnfoldFunction<T, U[]>} f - unary unfolding function that (possibly
 *    asynchronously) generates items a "page" at a time, where a "page" is some
 *    iterable value (such as an array)
 * @returns {(seed: T) => AsyncGenerator<U, void, undefined>} an async generator
 *    that individually yields each item from each page generated by the
 *    unfolding function
 * @template T - type of the argument expected by the function `f`
 * @template U - type of the elements produced by the returned generator
 */
function asyncFlatUnfold(f) {
  return async function* makeAsyncGenerator(seed) {
    for await (const items of asyncUnfold(f)(seed)) {
      yield* items;
    }
  }
}

/**
 * Returns an async iterable of arrays of values, where each value in an array is
 * obtained from one of the specified (async) iterables, and every value in an array
 * produces the same key when passed to the specified `key` function.
 *
 * Each generated array is the same length as the number of iterables, and each value at
 * a given index within the array was produced by the iterable at the same index within
 * the array of iterables.  An `undefined` value appears within an array when the
 * iterable at the corresponding index did not produce a value with the same key as the
 * non-`undefined` values within the array.
 *
 * Each iterable should produce values in ascending order according to the keys produced
 * by the specified `key` function, and each key should be unique amongst the values
 * produced by an iterable.
 *
 * @example
 * const nasaGranules = [{ granuleId: 'bar' }, { granuleId: 'foo' }];
 * const maapGranules = [{ granuleId: 'baz' }, { granuleId: 'foo' }];
 *
 * const zippedGranules = await asyncToArray(
 *   asyncZipBy(_.prop('granuleId'), nasaGranules, maapGranules)
 * );
 *
 * assert.deepEqual(zippedGranules, [
 *   // nasaGranules        maapGranules
 *   // ------------------  --------------------
 *   [{ granuleId: 'bar' }, undefined           ],
 *   [undefined,            { granuleId: 'baz' }],
 *   [{ granuleId: 'foo' }, { granuleId: 'foo' }],
 * ])
 *
 * const missingGranules = zippedGranules
 *   .filter(([nasaGranule, maapGranule]) => maapGranule === undefined)
 *   .map(([nasaGranule]) => nasaGranule);
 *
 * assert.deepEqual(missingGranules, [{ granuleId: 'bar' }]);
 *
 * @param {(value: V) => K} key - function that computes the unique key for a value,
 *    where the key must be a data type can be compared using the `<` and `===`
 *    operators (such as a string or a number)
 * @param  {...AsyncIterable<V>} iterables - an array of iterables of values to zip
 * @returns {AsyncIterable<Array<V | undefined>>} an iterable of arrays, where each array
 *    contains values from the specified iterables and each value in an array produces
 *    the same key when passed to the specified `key` function
 * @template V - the type of the values produced by the iterables
 * @template K - the type of the keys produced by the `key` function, when invoked with
 *    values of type `V`
 */
function asyncZipBy(key, ...iterables) {
  const toEntries = (iterable, i) => I.asyncMap((value) => [i, value], iterable);
  const entryIterables = iterables.map(toEntries);
  const compare = (x, y) => x < y ? -1 : x === y ? 0 : 1;
  const compareEntries = ([leftIndex, leftValue], [rightIndex, rightValue]) =>
    compare(key(leftValue), key(rightValue)) || compare(leftIndex, rightIndex);
  const asyncJoin = async (group) => {
    const valueAtIndex = Object.fromEntries(await I.asyncToArray(group));
    return Array.from({ length: iterables.length }, (_, i) => valueAtIndex[i]);
  }

  return I.execPipe(
    I.asyncCollate(compareEntries, ...entryIterables),
    I.asyncSplitGroups(([_index, value]) => key(value)),
    I.asyncMap(([_key, group]) => asyncJoin(group)),
  )
}

module.exports = {
  asyncFlatUnfold,
  asyncUnfold,
  asyncZipBy,
}
